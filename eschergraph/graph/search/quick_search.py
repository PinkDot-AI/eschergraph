from __future__ import annotations

from typing import Any
from typing import TYPE_CHECKING
from uuid import UUID

from attrs import define
from dotenv import load_dotenv

from eschergraph.agents.jinja_helper import process_template
from eschergraph.agents.providers.jina import JinaReranker
from eschergraph.agents.reranker import RerankerResult
from eschergraph.graph.persistence.metadata import Metadata

if TYPE_CHECKING:
  from eschergraph.graph import Graph

load_dotenv()
RAG_SEARCH = "search/question_with_context.jinja"


@define
class AttributeSearch:
  """This is the dataclass for the attribute search object."""

  text: str
  metadata: set[Metadata] | None
  parent_nodes: list[str]


def quick_search(
  graph: Graph,
  query: str,
) -> str:
  """Performs a quick search and Retrieval-Augmented Generation (RAG) using the vector database and language model.

  Args:
    query (str): The input string to search for relevant attributes in the graph.
    graph (Graph): The graph on which the quick search is performed.

  Returns:
    list[AttributeSearch]: A list of AttributeSearch objects containing the response generated by the language model.
  """
  # Retrieve and rank attributes based on the query
  if query.strip() == "":
    return "please ask a question"
  attributes: list[AttributeSearch] = _get_attributes(graph, query)
  chunks_string: str = ""
  if len(attributes) == 0:
    chunks_string = "Nothing found in the graph regarding this question!"
  else:
    for a in attributes:
      chunks_string += a.text + "\n"
  prompt: str = process_template(
    RAG_SEARCH, data={"CONTEXT": chunks_string, "QUERY": query}
  )
  answer: str | None = graph.model.get_plain_response(prompt)
  if answer:
    return answer
  else:
    return "Something went wrong with generating the answer"


def _get_attributes(graph: Graph, query: str) -> list[AttributeSearch]:
  """Gets and ranks all relevant objects in the graph based on the query.

  Args:
    query (str): The input query used to search and rank attributes.
    graph (Graph): The graph on which the quick search is performed.

  Returns:
    list[AttributeSearch]: A list of AttributeSearch objects representing the ranked attributes relevant to the query.
  """
  # Initialize search metadata for attributes
  search_metadata: dict[str, Any] = {"level": 0}

  # Perform the final search for attributes
  attributes_results = graph.vector_db.format_search_results(
    graph.vector_db.search(
      query=query,
      top_n=40,
      metadata=search_metadata,
      collection_name="main_collection",
    )
  )

  # Filter and reformat the reranked attributes before returning them
  return rerank_and_filter_attributes(graph, query, attributes_results, threshold=0.18)


def rerank(query: str, text_list: list[str], top_n: int = 10) -> list[RerankerResult]:
  """Rerank a list of texts based on their relevance to a given query.

  This function uses the JinaReranker to reorder the input texts based on their
  relevance to the provided query. It returns the top N results.

  Args:
    query (str): The query string used as the basis for reranking.
    text_list (list[str]): A list of text strings to be reranked.
    top_n (int, optional): The number of top results to return. Defaults to 10.
                            If top_n is greater than the length of text_list,
                            all results will be returned.

  Returns:
    list[RerankerResult]: A list of RerankerResult objects representing the
      reranked texts. Each RerankerResult typically contains the reranked text
      and its relevance score. The list is sorted in descending order of relevance.
  """
  reranked_attributes: list[RerankerResult] = JinaReranker().rerank(
    query=query,
    text_list=text_list,
    top_n=top_n,
  )
  return reranked_attributes


def rerank_and_filter_attributes(
  graph: Graph,
  query: str,
  attributes_results: list[dict[str, UUID | int | str | float | dict[str, Any]]],
  threshold: float = 0.2,
) -> list[AttributeSearch]:
  """Filters and reformats a list of reranked attributes based on relevance score.

  Args:
    graph (Graph): The graph.
    query (str): The question to find an answer for.
    attributes_results (list[dict[str, UUID | int | str | float | dict[str, Any]]]):
      A list of dictionaries containing the original search results with associated metadata.
    threshold (float): The reranker threshold.

  Returns:
    list[AttributeSearch]: A list of AttributeSearch objects that have been filtered by relevance
    score and enriched with the corresponding metadata and parent nodes.
  """
  attributes_string = [
    a["chunk"] for a in attributes_results if isinstance(a["chunk"], str)
  ]
  results_dict = {}
  for a in attributes_results:
    if isinstance(a["chunk"], str) and isinstance(a["metadata"], dict):
      metadata = a["metadata"]
      metadata["id"] = a["id"]
      results_dict[a["chunk"]] = metadata

  # rerank
  reranked_attributes = rerank(query, attributes_string, top_n=len(attributes_string))

  return filter_attributes(graph, reranked_attributes, results_dict, threshold)


def filter_attributes(
  graph: Graph,
  reranked_attributes: list[RerankerResult],
  results_dict: dict[str, dict[str, Any]],
  threshold: float,
) -> list[AttributeSearch]:
  """Filters reranked attributes based on relevance score and retrieves associated metadata.

  Args:
    graph (Graph): The graph holding the repository.
    reranked_attributes (list[RerankerResult]): A list of reranked attributes.
    results_dict (dict[str, dict[str, Any]]): The preprocessed attribute metadata.
    threshold (float): The relevance score threshold for filtering.

  Returns:
    list[AttributeSearch]: A list of filtered and enriched AttributeSearch objects.
  """
  filtered_attributes = []

  for r in reranked_attributes:
    if r.relevance_score <= threshold:
      break

    metadata = results_dict.get(r.text)
    if metadata:
      attribute = create_attribute_search(graph, r.text, metadata)
      if attribute:
        filtered_attributes.append(attribute)

  return filtered_attributes


def create_attribute_search(
  graph: Graph, text: str, metadata: dict[str, Any]
) -> AttributeSearch | None:
  """Creates an AttributeSearch object based on the metadata and graph nodes or edges.

  Args:
    graph (Graph): The graph holding the repository.
    text (str): The attribute text (chunk).
    metadata (dict[str, Any]): The associated metadata for the attribute.

  Returns:
    AttributeSearch | None: The constructed AttributeSearch object or None if no valid data.
  """
  metadata_obj, parent_nodes = None, []
  if metadata["type"] == "node":
    node = graph.repository.get_node_by_id(UUID(metadata["id"]))
    if node:
      metadata_obj = node.metadata
      parent_nodes = [node.name]

  elif metadata["type"] == "edge":
    edge = graph.repository.get_edge_by_id(UUID(metadata["id"]))
    if edge:
      metadata_obj = edge.metadata
      parent_nodes = [edge.to.name, edge.frm.name]

  elif metadata["type"] == "property":
    prop = graph.repository.get_property_by_id(UUID(metadata["id"]))
    if prop:
      metadata_obj = prop.metadata
      parent_nodes = [prop.node.name]

  if metadata_obj:
    return AttributeSearch(text=text, metadata=metadata_obj, parent_nodes=parent_nodes)

  return None

from __future__ import annotations

import os
from typing import Any
from uuid import UUID

from attrs import define
from dotenv import load_dotenv

from eschergraph.agents.jinja_helper import process_template
from eschergraph.agents.llm import Model
from eschergraph.agents.providers.jina import JinaReranker
from eschergraph.agents.reranker import RerankerResult
from eschergraph.exceptions import ExternalProviderException
from eschergraph.graph.persistence.metadata import Metadata
from eschergraph.graph.persistence.vector_db.vector_db import VectorDB
from eschergraph.graph.search.global_search import extract_entities_from

load_dotenv()
RAG_SEARCH = "search/rag_prompt.jinja"


@define
class AttributeSearch:
  """This is the dataclass for the attribute search object."""

  text: str
  metadata: Metadata
  parent_node: str


def search(vector_db: VectorDB, query: str, model: Model) -> str:
  """Performs a quick search and Retrieval-Augmented Generation (RAG) using the vector database and language model.

  Args:
      vector_db (VectorDB): The vector database instance used for searching and retrieving attributes.
      query (str): The input query string to search for relevant attributes in the graph.
      model (Model): The language model used to extract entities, generate prompts, and return a response.

  Returns:
      list[AttributeSearch]: A list of AttributeSearch objects containing the response generated by the language model.
  """
  # Retrieve and rank attributes based on the query
  attributes: list[AttributeSearch] = _get_attributes(vector_db, query, model)
  chunks_string: str = ""
  if len(attributes) == 0:
    chunks_string = "Nothing found in the graph regarding this question!"
  else:
    for a in attributes:
      chunks_string += a.text + "\n"
  prompt: str = process_template(
    RAG_SEARCH, data={"chunks": chunks_string, "query": query}
  )
  answer: str | None = model.get_plain_response(prompt)
  if answer:
    return answer
  else:
    return "Something went wrong with the generating the answer"


def _get_attributes(
  vector_db: VectorDB, query: str, model: Model
) -> list[AttributeSearch]:
  """Gets and ranks all relevant objects in the graph based on the query.

  Args:
      vector_db (VectorDB): The vector database instance used for searching and formatting results.
      query (str): The input query string used to search and rank attributes.
      model (Model): The language model used to extract entities from the query.

  Returns:
      list[AttributeSearch]: A list of AttributeSearch objects representing the ranked attributes relevant to the query.
  """
  # Extract nodes/entities from the query using the language model
  extracted_nodes = extract_entities_from(query=query, llm=model)

  # Initialize search metadata for attributes
  search_metadata = {
    "$and": [{"level": 0}, {"$or": [{"type": "edge"}, {"type": "property"}]}]
  }

  # Perform initial search for nodes if any extracted entities are found
  if extracted_nodes:
    results = vector_db.format_search_results(
      vector_db.search(
        query=", ".join(extracted_nodes),
        top_n=7,
        metadata={"$and": [{"level": 0}, {"type": "node"}]},
        collection_name="test_collection",
      )
    )
    filtered_nodes = [r["chunk"] for r in results]

    # Add filtering conditions to the search metadata if nodes were found
    if filtered_nodes:
      search_metadata["$and"].append({
        "$or": [
          {"entity1": {"$in": filtered_nodes}},
          {"entity2": {"$in": filtered_nodes}},
        ]
      })

  # Perform the final search for attributes
  attributes_results = vector_db.format_search_results(
    vector_db.search(
      query=query,
      top_n=30,
      metadata=search_metadata,
      collection_name="test_collection",
    )
  )
  api_key: str | None = os.getenv("JINA_API_KEY") or None
  attributes_string: list[str] = [
    a["chunk"] for a in attributes_results if isinstance(a["chunk"], str)
  ]
  if api_key:
    # Rerank the attributes using JinaReranker
    reranked_attributes = JinaReranker(api_key=api_key).rerank(
      query=query,
      text_list=attributes_string,
      top_n=len(attributes_results),
    )
  else:
    raise ExternalProviderException("Insert jina apikey")

  # Filter and reformat the reranked attributes before returning them
  return _filter_reformat_attributes(reranked_attributes, attributes_results)


def _filter_reformat_attributes(
  reranked_attributes: list[RerankerResult],
  attributes_results: list[dict[str, UUID | int | str | float | dict[str, Any]]],
) -> list[AttributeSearch]:
  """Filters and reformats a list of reranked attributes based on relevance score.

  Args:
      reranked_attributes (list[RerankerResult]): A list of reranked attributes, each containing a relevance score and text.
      attributes_results (list[dict[str, UUID | int | str | float | dict[str, Any]]]):
          A list of dictionaries containing the original search results with associated metadata.

  Returns:
      list[AttributeSearch]: A list of AttributeSearch objects that have been filtered by relevance
      score and enriched with the corresponding metadata and parent nodes.
  """
  # Preprocess attributes_results into a dictionary for quick lookups
  results_dict: dict[str, dict[str, Any]] = {
    a["chunk"]: a["metadata"]
    for a in attributes_results
    if isinstance(a["chunk"], str) and isinstance(a["metadata"], dict)
  }

  attributes_filtered: list[AttributeSearch] = []

  for r in reranked_attributes:
    if r.relevance_score <= 0.15:
      break

    # Direct lookup from the dictionary
    metadata = results_dict.get(r.text)

    if metadata:
      # Create the AttributeSearch object with the metadata and parent nodes
      obj = AttributeSearch(
        text=r.text,
        metadata=Metadata(
          document_id=metadata["document_id"], chunk_id=metadata["chunk_id"]
        ),
        parent_node="",
      )

      attributes_filtered.append(obj)

  return attributes_filtered
